// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,ModelFlag,Object,SpaceFlags};
use glib::{translate::*};


/// Returns the babl object representing the color component given by
/// `name` such as for example "R", "cyan" or "CIE L".
#[doc(alias = "babl_component")]
pub fn component(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_component(name.to_glib_none().0))
    }
}

//#[doc(alias = "babl_component_new")]
//pub fn component_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_component_new() }
//}

/// Returns the RGB space defined for the destination of conversion.
#[doc(alias = "babl_conversion_get_destination_space")]
pub fn conversion_get_destination_space(conversion: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_conversion_get_destination_space(conversion.to_glib_none().0))
    }
}

/// Returns the RGB space defined for the source of conversion.
#[doc(alias = "babl_conversion_get_source_space")]
pub fn conversion_get_source_space(conversion: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_conversion_get_source_space(conversion.to_glib_none().0))
    }
}

//#[doc(alias = "babl_conversion_new")]
//pub fn conversion_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_conversion_new() }
//}

/// Deinitializes the babl library and frees any resources used when
/// matched with the number of calls to [`init()`][crate::init()].
#[doc(alias = "babl_exit")]
pub fn exit() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_exit();
    }
}

//#[doc(alias = "babl_fast_fish")]
//pub fn fast_fish(source_format: /*Unimplemented*/Option<Basic: Pointer>, destination_format: /*Unimplemented*/Option<Basic: Pointer>, performance: &str) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_fast_fish() }
//}

//#[doc(alias = "babl_fish")]
//pub fn fish(source_format: /*Unimplemented*/Option<Basic: Pointer>, destination_format: /*Unimplemented*/Option<Basic: Pointer>) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_fish() }
//}

//#[doc(alias = "babl_fish_get_process")]
//pub fn fish_get_process(babl: &Object) -> Option<Box_<dyn Fn(&Object, &str, &str, libc::c_long) + 'static>> {
//    unsafe { TODO: call ffi:babl_fish_get_process() }
//}

/// Returns the babl object representing the color format given by
/// `name` such as for example "RGB u8", "CMYK float" or "CIE Lab u16",
/// creates a format using the sRGB space, to also specify the color space
/// and TRCs for a format, see babl_format_with_space.
#[doc(alias = "babl_format")]
pub fn format(encoding: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format(encoding.to_glib_none().0))
    }
}

/// Returns 1 if the provided format name is known by babl or 0 if it is
/// not. Can also be used to verify that specific extension formats are
/// available (though this can also be inferred from the version of babl).
#[doc(alias = "babl_format_exists")]
pub fn format_exists(name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_exists(name.to_glib_none().0)
    }
}

/// Returns the bytes per pixel for a babl color format.
#[doc(alias = "babl_format_get_bytes_per_pixel")]
pub fn format_get_bytes_per_pixel(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_get_bytes_per_pixel(format.to_glib_none().0)
    }
}

/// Returns the components and data type, without space suffix.
#[doc(alias = "babl_format_get_encoding")]
pub fn format_get_encoding(babl: &Object) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_encoding(babl.to_glib_none().0))
    }
}

/// Return the model used for constructing the format.
#[doc(alias = "babl_format_get_model")]
pub fn format_get_model(format: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_model(format.to_glib_none().0))
    }
}

/// Returns the number of components for the given `format`.
#[doc(alias = "babl_format_get_n_components")]
pub fn format_get_n_components(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_get_n_components(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_get_space")]
pub fn format_get_space(format: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_space(format.to_glib_none().0))
    }
}

/// Returns the type in the given `format` for the given
/// `component_index`.
#[doc(alias = "babl_format_get_type")]
pub fn format_get_type(format: &Object, component_index: i32) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_type(format.to_glib_none().0, component_index))
    }
}

/// Returns whether the `format` has an alpha channel.
#[doc(alias = "babl_format_has_alpha")]
pub fn format_has_alpha(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_has_alpha(format.to_glib_none().0)
    }
}

/// Returns whether the `format` is a format_n type.
#[doc(alias = "babl_format_is_format_n")]
pub fn format_is_format_n(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_is_format_n(format.to_glib_none().0)
    }
}

/// check whether a format is a palette backed format.
#[doc(alias = "babl_format_is_palette")]
pub fn format_is_palette(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_is_palette(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_n")]
pub fn format_n(type_: &Object, components: i32) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_n(type_.to_glib_none().0, components))
    }
}

//#[doc(alias = "babl_format_new")]
//pub fn format_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_format_new() }
//}

/// Returns the babl object representing the color format given by
/// `name` such as for example "RGB u8", "R'G'B'A float", "Y float" with
/// a specific RGB working space used as the space, the resulting format
/// has -space suffixed to it, unless the space requested is sRGB then
/// the unsuffixed version is used. If a format is passed in as space
/// the space of the format is used.
#[doc(alias = "babl_format_with_space")]
pub fn format_with_space(encoding: &str, space: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_with_space(encoding.to_glib_none().0, space.to_glib_none().0))
    }
}

#[doc(alias = "babl_get_model_flags")]
#[doc(alias = "get_model_flags")]
pub fn model_flags(model: &Object) -> ModelFlag {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::babl_get_model_flags(model.to_glib_none().0))
    }
}

/// Returns a string describing a Babl object.
#[doc(alias = "babl_get_name")]
#[doc(alias = "get_name")]
pub fn name(babl: &Object) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_get_name(babl.to_glib_none().0))
    }
}

//#[doc(alias = "babl_get_user_data")]
//#[doc(alias = "get_user_data")]
//pub fn user_data(babl: &Object) -> /*Unimplemented*/Option<Basic: Pointer> {
//    unsafe { TODO: call ffi:babl_get_user_data() }
//}

/// Get the version information on the babl library
///
/// # Returns
///
///
/// ## `major`
/// The major version number
///
/// ## `minor`
/// The minor version number
///
/// ## `micro`
/// The micro version number
#[doc(alias = "babl_get_version")]
#[doc(alias = "get_version")]
pub fn version() -> (i32, i32, i32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut major = std::mem::MaybeUninit::uninit();
        let mut minor = std::mem::MaybeUninit::uninit();
        let mut micro = std::mem::MaybeUninit::uninit();
        ffi::babl_get_version(major.as_mut_ptr(), minor.as_mut_ptr(), micro.as_mut_ptr());
        (major.assume_init(), minor.assume_init(), micro.assume_init())
    }
}

#[doc(alias = "babl_icc_get_key")]
pub fn icc_get_key(icc_data: &str, key: &str, language: &str, country: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    let icc_length = icc_data.len() as _;
    unsafe {
        from_glib_full(ffi::babl_icc_get_key(icc_data.to_glib_none().0, icc_length, key.to_glib_none().0, language.to_glib_none().0, country.to_glib_none().0))
    }
}

/// Initializes the babl library.
#[doc(alias = "babl_init")]
pub fn init() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_init();
    }
}

/// introspect a given BablObject
/// ## `babl`
/// A `Babl`
#[doc(alias = "babl_introspect")]
pub fn introspect(babl: &mut Object) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_introspect(babl.to_glib_none_mut().0);
    }
}

/// Returns the babl object representing the color model given by `name`
/// such as for example "RGB", "CMYK" or "CIE Lab".
#[doc(alias = "babl_model")]
pub fn model(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_model(name.to_glib_none().0))
    }
}

///
/// # Returns
///
/// 0 if the name of the model in babl does not correspond to the
/// provided model name.
#[doc(alias = "babl_model_is")]
pub fn model_is(babl: &Object, model_name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_model_is(babl.to_glib_none().0, model_name.to_glib_none().0)
    }
}

//#[doc(alias = "babl_model_new")]
//pub fn model_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_model_new() }
//}

/// The models for formats also have a space in babl, try to avoid code
/// needing to use this.
#[doc(alias = "babl_model_with_space")]
pub fn model_with_space(name: &str, space: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_model_with_space(name.to_glib_none().0, space.to_glib_none().0))
    }
}

/// reset a palette to initial state, frees up some caches that optimize
/// conversions.
#[doc(alias = "babl_palette_reset")]
pub fn palette_reset(babl: &Object) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_palette_reset(babl.to_glib_none().0);
    }
}

//#[doc(alias = "babl_palette_set_palette")]
//pub fn palette_set_palette(babl: &Object, format: &Object, data: &[u8], count: i32) {
//    unsafe { TODO: call ffi:babl_palette_set_palette() }
//}

//#[doc(alias = "babl_process")]
//pub fn process(babl_fish: &Object, source: /*Unimplemented*/Option<Basic: Pointer>, destination: /*Unimplemented*/Option<Basic: Pointer>, n: libc::c_long) -> libc::c_long {
//    unsafe { TODO: call ffi:babl_process() }
//}

//#[doc(alias = "babl_process_rows")]
//pub fn process_rows(babl_fish: &Object, source: /*Unimplemented*/Option<Basic: Pointer>, source_stride: i32, dest: /*Unimplemented*/Option<Basic: Pointer>, dest_stride: i32, n: libc::c_long, rows: i32) -> libc::c_long {
//    unsafe { TODO: call ffi:babl_process_rows() }
//}

/// Returns the babl object representing the `horizontal` and `vertical`
/// sampling such as for example 2, 2 for the chroma components in
/// YCbCr.
#[doc(alias = "babl_sampling")]
pub fn sampling(horizontal: i32, vertical: i32) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_sampling(horizontal, vertical))
    }
}

//#[doc(alias = "babl_set_user_data")]
//pub fn set_user_data(babl: &Object, data: /*Unimplemented*/Option<Basic: Pointer>) {
//    unsafe { TODO: call ffi:babl_set_user_data() }
//}

/// Returns the babl object representing the specific RGB matrix color
/// working space referred to by name. Babl knows of:
///  sRGB, Rec2020, Adobish, Apple and ProPhoto
#[doc(alias = "babl_space")]
pub fn space(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space(name.to_glib_none().0))
    }
}

/// Creates a new babl-space/ RGB matrix color space definition with the
/// specified CIE xy(Y) values for white point: wx, wy and primary
/// chromaticities: rx,ry,gx,gy,bx,by and TRCs to be used. After registering a
/// new babl-space it can be used with [`space()`][crate::space()] passing its name;
///
/// Internally this does the math to derive the RGBXYZ matrix as used in an ICC
/// profile.
/// ## `name`
/// The name for the color space
/// ## `wx`
/// The X-coordinate of the color space's white point
/// ## `wy`
/// The Y-coordinate of the color space's white point
/// ## `rx`
/// The X-coordinate of the red primary
/// ## `ry`
/// The Y-coordinate of the red primary
/// ## `gx`
/// The X-coordinate of the green primary
/// ## `gy`
/// The Y-coordinate of the green primary
/// ## `bx`
/// The X-coordinate of the blue primary
/// ## `by`
/// The Y-coordinate of the blue primary
/// ## `trc_red`
/// The red component of the TRC.
/// ## `trc_green`
/// The green component of the TRC (can be [`None`] if it's
///  the same as `trc_red`).
/// ## `trc_blue`
/// The blue component of the TRC (can be [`None`] if it's
///  the same as `trc_red`).
/// ## `flags`
/// The [`SpaceFlags`][crate::SpaceFlags]
#[doc(alias = "babl_space_from_chromaticities")]
pub fn space_from_chromaticities(name: Option<&str>, wx: f64, wy: f64, rx: f64, ry: f64, gx: f64, gy: f64, bx: f64, by: f64, trc_red: &Object, trc_green: Option<&Object>, trc_blue: Option<&Object>, flags: SpaceFlags) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space_from_chromaticities(name.to_glib_none().0, wx, wy, rx, ry, gx, gy, bx, by, trc_red.to_glib_none().0, trc_green.to_glib_none().0, trc_blue.to_glib_none().0, flags.into_glib()))
    }
}

/// Creates a new RGB matrix color space definition using a precomputed D50
/// adapted 3x3 matrix and associated CIE XYZ whitepoint, as possibly read from
/// an ICC profile.
/// ## `name`
/// The name for the color space
/// ## `wx`
/// The X-coordinate of the color space's white point
/// ## `wy`
/// The Y-coordinate of the color space's white point
/// ## `wz`
/// The Z-coordinate of the color space's white point
/// ## `rx`
/// The X-coordinate of the red primary
/// ## `gx`
/// The X-coordinate of the green primary
/// ## `bx`
/// The X-coordinate of the blue primary
/// ## `ry`
/// The Y-coordinate of the red primary
/// ## `gy`
/// The Y-coordinate of the green primary
/// ## `by`
/// The Y-coordinate of the blue primary
/// ## `rz`
/// The Z-coordinate of the red primary
/// ## `gz`
/// The Z-coordinate of the green primary
/// ## `bz`
/// The Z-coordinate of the blue primary
/// ## `trc_red`
/// The red component of the TRC.
/// ## `trc_green`
/// The green component of the TRC (can be [`None`] if it's
///  the same as `trc_red`).
/// ## `trc_blue`
/// The blue component of the TRC (can be [`None`] if it's
///  the same as `trc_red`).
#[doc(alias = "babl_space_from_rgbxyz_matrix")]
pub fn space_from_rgbxyz_matrix(name: Option<&str>, wx: f64, wy: f64, wz: f64, rx: f64, gx: f64, bx: f64, ry: f64, gy: f64, by: f64, rz: f64, gz: f64, bz: f64, trc_red: &Object, trc_green: Option<&Object>, trc_blue: Option<&Object>) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space_from_rgbxyz_matrix(name.to_glib_none().0, wx, wy, wz, rx, gx, bx, ry, gy, by, rz, gz, bz, trc_red.to_glib_none().0, trc_green.to_glib_none().0, trc_blue.to_glib_none().0))
    }
}

#[doc(alias = "babl_space_get_gamma")]
pub fn space_get_gamma(space: &Object) -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_space_get_gamma(space.to_glib_none().0)
    }
}

/// Return pointer to ICC profile for space note that this is
/// the ICC profile for R'G'B', though in formats only supporting linear
/// like EXR GEGL chooses to load this lienar data as RGB and use the sRGB
/// TRC.
/// ## `babl`
/// a `Babl`
///
/// # Returns
///
/// pointer to ICC profile data.
///
/// ## `length`
/// Length of the profile in bytes.
#[doc(alias = "babl_space_get_icc")]
pub fn space_get_icc(babl: &Object) -> (glib::GString, i32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = from_glib_none(ffi::babl_space_get_icc(babl.to_glib_none().0, length.as_mut_ptr()));
        (ret, length.assume_init())
    }
}

/// Retrieve the relevant RGB luminance constants for a babl space.
/// ## `space`
/// a BablSpace
///
/// # Returns
///
///
/// ## `red_luminance`
/// Location for the red luminance factor.
///
/// ## `green_luminance`
/// Location for the green luminance factor.
///
/// ## `blue_luminance`
/// Location for the blue luminance factor.
#[doc(alias = "babl_space_get_rgb_luminance")]
pub fn space_get_rgb_luminance(space: &Object) -> (f64, f64, f64) {
    assert_initialized_main_thread!();
    unsafe {
        let mut red_luminance = std::mem::MaybeUninit::uninit();
        let mut green_luminance = std::mem::MaybeUninit::uninit();
        let mut blue_luminance = std::mem::MaybeUninit::uninit();
        ffi::babl_space_get_rgb_luminance(space.to_glib_none().0, red_luminance.as_mut_ptr(), green_luminance.as_mut_ptr(), blue_luminance.as_mut_ptr());
        (red_luminance.assume_init(), green_luminance.assume_init(), blue_luminance.assume_init())
    }
}

#[doc(alias = "babl_space_is_cmyk")]
pub fn space_is_cmyk(space: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_space_is_cmyk(space.to_glib_none().0)
    }
}

#[doc(alias = "babl_space_is_gray")]
pub fn space_is_gray(space: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_space_is_gray(space.to_glib_none().0)
    }
}

/// Creates a variant of an existing space with different trc.
#[doc(alias = "babl_space_with_trc")]
pub fn space_with_trc(space: &Object, trc: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space_with_trc(space.to_glib_none().0, trc.to_glib_none().0))
    }
}

/// Look up a TRC by name, "sRGB" and "linear" are recognized
/// strings in a stock babl configuration.
#[doc(alias = "babl_trc")]
pub fn trc(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_trc(name.to_glib_none().0))
    }
}

/// Creates a Babl TRC for a specific gamma value, it will be given
/// a name that is a short string representation of the value.
#[doc(alias = "babl_trc_gamma")]
pub fn trc_gamma(gamma: f64) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_trc_gamma(gamma))
    }
}

/// Returns the babl object representing the data type given by `name`
/// such as for example "u8", "u16" or "float".
#[doc(alias = "babl_type")]
#[doc(alias = "type")]
pub fn type_(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_type(name.to_glib_none().0))
    }
}

//#[doc(alias = "babl_type_new")]
//pub fn type_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_type_new() }
//}
