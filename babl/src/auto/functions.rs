// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,ModelFlag,Object,SpaceFlags};
use glib::{translate::*};


#[doc(alias = "babl_component")]
pub fn component(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_component(name.to_glib_none().0))
    }
}

//#[doc(alias = "babl_component_new")]
//pub fn component_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_component_new() }
//}

#[doc(alias = "babl_conversion_get_destination_space")]
pub fn conversion_get_destination_space(conversion: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_conversion_get_destination_space(conversion.to_glib_none().0))
    }
}

#[doc(alias = "babl_conversion_get_source_space")]
pub fn conversion_get_source_space(conversion: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_conversion_get_source_space(conversion.to_glib_none().0))
    }
}

//#[doc(alias = "babl_conversion_new")]
//pub fn conversion_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_conversion_new() }
//}

#[doc(alias = "babl_exit")]
pub fn exit() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_exit();
    }
}

//#[doc(alias = "babl_fast_fish")]
//pub fn fast_fish(source_format: /*Unimplemented*/Option<Basic: Pointer>, destination_format: /*Unimplemented*/Option<Basic: Pointer>, performance: &str) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_fast_fish() }
//}

//#[doc(alias = "babl_fish")]
//pub fn fish(source_format: /*Unimplemented*/Option<Basic: Pointer>, destination_format: /*Unimplemented*/Option<Basic: Pointer>) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_fish() }
//}

//#[doc(alias = "babl_fish_get_process")]
//pub fn fish_get_process(babl: &Object) -> Option<Box_<dyn Fn(&Object, &str, &str, libc::c_long) + 'static>> {
//    unsafe { TODO: call ffi:babl_fish_get_process() }
//}

#[doc(alias = "babl_format")]
pub fn format(encoding: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format(encoding.to_glib_none().0))
    }
}

#[doc(alias = "babl_format_exists")]
pub fn format_exists(name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_exists(name.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_get_bytes_per_pixel")]
pub fn format_get_bytes_per_pixel(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_get_bytes_per_pixel(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_get_encoding")]
pub fn format_get_encoding(babl: &Object) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_encoding(babl.to_glib_none().0))
    }
}

#[doc(alias = "babl_format_get_model")]
pub fn format_get_model(format: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_model(format.to_glib_none().0))
    }
}

#[doc(alias = "babl_format_get_n_components")]
pub fn format_get_n_components(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_get_n_components(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_get_space")]
pub fn format_get_space(format: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_space(format.to_glib_none().0))
    }
}

#[doc(alias = "babl_format_get_type")]
pub fn format_get_type(format: &Object, component_index: i32) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_get_type(format.to_glib_none().0, component_index))
    }
}

#[doc(alias = "babl_format_has_alpha")]
pub fn format_has_alpha(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_has_alpha(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_is_format_n")]
pub fn format_is_format_n(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_is_format_n(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_is_palette")]
pub fn format_is_palette(format: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_format_is_palette(format.to_glib_none().0)
    }
}

#[doc(alias = "babl_format_n")]
pub fn format_n(type_: &Object, components: i32) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_n(type_.to_glib_none().0, components))
    }
}

//#[doc(alias = "babl_format_new")]
//pub fn format_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_format_new() }
//}

#[doc(alias = "babl_format_with_space")]
pub fn format_with_space(encoding: &str, space: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_format_with_space(encoding.to_glib_none().0, space.to_glib_none().0))
    }
}

#[doc(alias = "babl_get_model_flags")]
#[doc(alias = "get_model_flags")]
pub fn model_flags(model: &Object) -> ModelFlag {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::babl_get_model_flags(model.to_glib_none().0))
    }
}

#[doc(alias = "babl_get_name")]
#[doc(alias = "get_name")]
pub fn name(babl: &Object) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_get_name(babl.to_glib_none().0))
    }
}

//#[doc(alias = "babl_get_user_data")]
//#[doc(alias = "get_user_data")]
//pub fn user_data(babl: &Object) -> /*Unimplemented*/Option<Basic: Pointer> {
//    unsafe { TODO: call ffi:babl_get_user_data() }
//}

#[doc(alias = "babl_get_version")]
#[doc(alias = "get_version")]
pub fn version() -> (i32, i32, i32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut major = std::mem::MaybeUninit::uninit();
        let mut minor = std::mem::MaybeUninit::uninit();
        let mut micro = std::mem::MaybeUninit::uninit();
        ffi::babl_get_version(major.as_mut_ptr(), minor.as_mut_ptr(), micro.as_mut_ptr());
        (major.assume_init(), minor.assume_init(), micro.assume_init())
    }
}

#[doc(alias = "babl_icc_get_key")]
pub fn icc_get_key(icc_data: &str, key: &str, language: &str, country: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    let icc_length = icc_data.len() as _;
    unsafe {
        from_glib_full(ffi::babl_icc_get_key(icc_data.to_glib_none().0, icc_length, key.to_glib_none().0, language.to_glib_none().0, country.to_glib_none().0))
    }
}

#[doc(alias = "babl_init")]
pub fn init() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_init();
    }
}

#[doc(alias = "babl_introspect")]
pub fn introspect(babl: &mut Object) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_introspect(babl.to_glib_none_mut().0);
    }
}

#[doc(alias = "babl_model")]
pub fn model(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_model(name.to_glib_none().0))
    }
}

#[doc(alias = "babl_model_is")]
pub fn model_is(babl: &Object, model_name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_model_is(babl.to_glib_none().0, model_name.to_glib_none().0)
    }
}

//#[doc(alias = "babl_model_new")]
//pub fn model_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_model_new() }
//}

#[doc(alias = "babl_model_with_space")]
pub fn model_with_space(name: &str, space: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_model_with_space(name.to_glib_none().0, space.to_glib_none().0))
    }
}

#[doc(alias = "babl_palette_reset")]
pub fn palette_reset(babl: &Object) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_palette_reset(babl.to_glib_none().0);
    }
}

//#[doc(alias = "babl_palette_set_palette")]
//pub fn palette_set_palette(babl: &Object, format: &Object, data: &[u8], count: i32) {
//    unsafe { TODO: call ffi:babl_palette_set_palette() }
//}

//#[doc(alias = "babl_process")]
//pub fn process(babl_fish: &Object, source: /*Unimplemented*/Option<Basic: Pointer>, destination: /*Unimplemented*/Option<Basic: Pointer>, n: libc::c_long) -> libc::c_long {
//    unsafe { TODO: call ffi:babl_process() }
//}

//#[doc(alias = "babl_process_rows")]
//pub fn process_rows(babl_fish: &Object, source: /*Unimplemented*/Option<Basic: Pointer>, source_stride: i32, dest: /*Unimplemented*/Option<Basic: Pointer>, dest_stride: i32, n: libc::c_long, rows: i32) -> libc::c_long {
//    unsafe { TODO: call ffi:babl_process_rows() }
//}

#[doc(alias = "babl_sampling")]
pub fn sampling(horizontal: i32, vertical: i32) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_sampling(horizontal, vertical))
    }
}

//#[doc(alias = "babl_set_user_data")]
//pub fn set_user_data(babl: &Object, data: /*Unimplemented*/Option<Basic: Pointer>) {
//    unsafe { TODO: call ffi:babl_set_user_data() }
//}

#[doc(alias = "babl_space")]
pub fn space(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space(name.to_glib_none().0))
    }
}

#[doc(alias = "babl_space_from_chromaticities")]
pub fn space_from_chromaticities(name: Option<&str>, wx: f64, wy: f64, rx: f64, ry: f64, gx: f64, gy: f64, bx: f64, by: f64, trc_red: &Object, trc_green: Option<&Object>, trc_blue: Option<&Object>, flags: SpaceFlags) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space_from_chromaticities(name.to_glib_none().0, wx, wy, rx, ry, gx, gy, bx, by, trc_red.to_glib_none().0, trc_green.to_glib_none().0, trc_blue.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "babl_space_from_rgbxyz_matrix")]
pub fn space_from_rgbxyz_matrix(name: Option<&str>, wx: f64, wy: f64, wz: f64, rx: f64, gx: f64, bx: f64, ry: f64, gy: f64, by: f64, rz: f64, gz: f64, bz: f64, trc_red: &Object, trc_green: Option<&Object>, trc_blue: Option<&Object>) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space_from_rgbxyz_matrix(name.to_glib_none().0, wx, wy, wz, rx, gx, bx, ry, gy, by, rz, gz, bz, trc_red.to_glib_none().0, trc_green.to_glib_none().0, trc_blue.to_glib_none().0))
    }
}

#[doc(alias = "babl_space_get_gamma")]
pub fn space_get_gamma(space: &Object) -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_space_get_gamma(space.to_glib_none().0)
    }
}

#[doc(alias = "babl_space_get_icc")]
pub fn space_get_icc(babl: &Object) -> (glib::GString, i32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = from_glib_none(ffi::babl_space_get_icc(babl.to_glib_none().0, length.as_mut_ptr()));
        (ret, length.assume_init())
    }
}

#[doc(alias = "babl_space_get_rgb_luminance")]
pub fn space_get_rgb_luminance(space: &Object) -> (f64, f64, f64) {
    assert_initialized_main_thread!();
    unsafe {
        let mut red_luminance = std::mem::MaybeUninit::uninit();
        let mut green_luminance = std::mem::MaybeUninit::uninit();
        let mut blue_luminance = std::mem::MaybeUninit::uninit();
        ffi::babl_space_get_rgb_luminance(space.to_glib_none().0, red_luminance.as_mut_ptr(), green_luminance.as_mut_ptr(), blue_luminance.as_mut_ptr());
        (red_luminance.assume_init(), green_luminance.assume_init(), blue_luminance.assume_init())
    }
}

#[doc(alias = "babl_space_is_cmyk")]
pub fn space_is_cmyk(space: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_space_is_cmyk(space.to_glib_none().0)
    }
}

#[doc(alias = "babl_space_is_gray")]
pub fn space_is_gray(space: &Object) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::babl_space_is_gray(space.to_glib_none().0)
    }
}

#[doc(alias = "babl_space_with_trc")]
pub fn space_with_trc(space: &Object, trc: &Object) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_space_with_trc(space.to_glib_none().0, trc.to_glib_none().0))
    }
}

#[doc(alias = "babl_trc")]
pub fn trc(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_trc(name.to_glib_none().0))
    }
}

#[doc(alias = "babl_trc_gamma")]
pub fn trc_gamma(gamma: f64) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_trc_gamma(gamma))
    }
}

#[doc(alias = "babl_type")]
#[doc(alias = "type")]
pub fn type_(name: &str) -> Option<Object> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::babl_type(name.to_glib_none().0))
    }
}

//#[doc(alias = "babl_type_new")]
//pub fn type_new(first_arg: /*Unimplemented*/Option<Basic: Pointer>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<Object> {
//    unsafe { TODO: call ffi:babl_type_new() }
//}
